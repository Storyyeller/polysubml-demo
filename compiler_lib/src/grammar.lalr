#![allow(unused_braces)]

use lalrpop_util::ParseError;

use super::ast; // super instead of self because lalrpop wraps this in an internal module
use super::spans;

grammar(ctx: &mut ast::ParserContext<'_, 'input>);

extern {
    type Error = (&'static str, spans::Span);
}

// Tokens ////////////////////////////////////////////////////////////
match {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r#"\(\*[^*]*\*+(?:[^\)*][^*]*\*+)*\)"# => { },  // Skip `(* comments *)`
} else {
    _
}


StringIdent: &'input str = r"[A-Za-z_]\w*"=> <>;
Ident: ast::StringId = StringIdent => ctx.strings.get_or_intern(<>);
Tag: ast::StringId = "`" <Ident>;

IntLiteral: String = {
    <l: @L> <s: r"-?(?:[0-9]+)"> <r: @R> =>? {
        let s2 = s.trim_start_matches('-');
        if s2 != "0" && s2.starts_with("0") {
            Err(ParseError::User {
                error: ("SyntaxError: Numbers can't contain leading 0s", ctx.span_maker.span(l, r))
            })
        } else {
            Ok(String::from(s))
        }
    },
};
FloatLiteral: String =
    <r"-?(?:0|[1-9][0-9]*)\.[0-9]*(?:[eE]-?[0-9]+)?"> => String::from(<>);
FloatLiteralNoDot: String =
    <r"-?(?:0|[1-9][0-9]*)[eE]-?[0-9]+"> => String::from(<>);
StringLiteral: String =
    <r#""[^\\"\n\r]*(?:\\[tn'"\\][^\\"\n\r]*)*""#> => String::from(<>);


// make sure __proto__ is not considered a valid identifier
Illegal = "__proto__";


// Macros ////////////////////////////////////////////////////////////
Box<T>: Box<T> = {
    <T> => Box::new(<>),
}
SepList<T, Sep>: Vec<T> = {
    <v:(<T> Sep)*> <e:T> => {
        let mut v = v;
        v.push(e);
        v
    }
};
SepListOpt<T, Sep>: Vec<T> = {
    SepList<T, Sep>,
    => Vec::new(),
};






Spanned<T>: spans::Spanned<T> = {
    <l: @L> <val: T> <r: @R> => (val, ctx.span_maker.span(l, r))
};

// Types /////////////////////////////////////////////////////////////
KeyPairType: ast::KeyPairType = {
    <name: Spanned<Ident>> ":" <ty: SType> => (name, ast::FieldTypeDecl::Imm(ty)),
    "mut" <name: Spanned<Ident>> ":" <ty: SType> => (name, ast::FieldTypeDecl::RWSame(ty)),
    "mut" <name: Spanned<Ident>> ":" <ty: SType> "<-" <ty2: SType> => (name, ast::FieldTypeDecl::RWPair(ty, ty2)),
}
RecordTypeParamList = ("type" <TypeParam> ";")*;

RecordTypeSub = "{" <RecordTypeParamList> <SepListOpt<KeyPairType, ";">> "}";
RecordType: ast::TypeExpr = {
    Spanned<RecordTypeSub> => {
        let ((types, fields), span) = <>;
        let base_type = ast::TypeExpr::Record(fields);

        if !types.is_empty() {
            ast::TypeExpr::Poly(types, Box::new((base_type, span)), ast::PolyKind::Existential)
        } else {
            base_type 
        }
    }
}

VariantType = <Spanned<Tag>> "of"? <Box<Spanned<TupleType>>>;
CaseType: ast::TypeExpr = {
    "[" <SepList<VariantType, "|">> "]" => ast::TypeExpr::Case(<>)
}

SimpleType: ast::TypeExpr = {
    Ident => {
        match ctx.strings.resolve(&<>) {
            "any" => ast::TypeExpr::Top,
            "never" => ast::TypeExpr::Bot,
            "_" => ast::TypeExpr::Hole,
            _ => ast::TypeExpr::Ident(<>),
        }
    },

    RecordType,
    CaseType,
    "(" <Type> ")",
}

TupleType: ast::TypeExpr = {
    SepList<Spanned<SimpleType>, "*"> => {
        ast::make_tuple_type(<>, &mut ctx.strings)
    }
}

IntersectType: ast::TypeExpr = {
    SepList<Spanned<TupleType>, "&"> => ast::make_join_ast(ast::JoinKind::Intersect, <>)
}
UnionType: ast::TypeExpr = {
    SepList<Spanned<IntersectType>, "|"> => ast::make_join_ast(ast::JoinKind::Union, <>)
}

NoFunType = UnionType;
SNoFunType = Spanned<NoFunType>;

TypeParamAlias = "as" <Spanned<Ident>>;
TypeParam: ast::TypeParam = {
    <Spanned<Ident>> <TypeParamAlias?> => ast::TypeParam::new(<>),
}
FuncTypeParamList = "type" <TypeParam+> ".";
FuncTypeSub = <FuncTypeParamList?> <Box<SNoFunType>> "->" <Box<SType>>;
FuncType: ast::TypeExpr = {
    Spanned<FuncTypeSub> => {
        let ((types, arg, ret), span) = <>;
        let base_type = ast::TypeExpr::Func(arg, ret);

        if let Some(types) = types {
            ast::TypeExpr::Poly(types, Box::new((base_type, span)), ast::PolyKind::Universal)
        } else {
            base_type 
        }
    }
}

Type = {
    NoFunType,
    FuncType,
    "rec" <Ident> "=" <Box<SType>> => ast::TypeExpr::RecursiveDef(<>),
}
SType = Spanned<Type>;



//////////////////////////////////////////////////////////////////////
// Expressions ///////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////


// SimpleExpr ////////////////////////////////////////////////////////
FieldAccess = Spanned<("." <Ident>)>;
FieldAccessExpr: ast::Expr = {
    Box<SSimpleExpr> FieldAccess => {
        ast::expr::field_access(<>)
    }
}

InstantiateParam = {
    <Ident> "=" <SType>,
}
InstantiateParams = {
    "[" <Spanned<SepListOpt<InstantiateParam, ";">>> "]",
}
InstantiateUni: ast::Expr = {
    // Span is not used here, but is needed to prevent grammar conflicts
    Spanned<Box<SSimpleExpr>> InstantiateParams => {
        let ((sub, _), types) = (<>);
        let kind = ast::InstantiateSourceKind::ExplicitParams(types.0.is_empty());
        ast::expr::instantiate_uni(sub, types, kind)
    }
}
InstantiateExist: ast::Expr = {
    // Span is unused but needed to avoid grammar conflicts
    <Spanned<Box<SSimpleExpr>>> "[" <InstantiateParams> "]" => {
        let ((sub, _), types) = (<>);
        let sub = match sub.0 {
            ast::Expr::InstantiateExist(inst_expr) => inst_expr.expr,
            _ => sub,
        };

        let kind = ast::InstantiateSourceKind::ExplicitParams(types.0.is_empty());
        ast::expr::instantiate_exist(sub, types, kind)
    }
}

RhsEqExpr = "=" <Box<SNoSemiExpr>>;
KeyPairExpr: ast::expr::KeyPair = {
    <ismut: "mut"?> <name: Spanned<Ident>> <ty: TypeAscription?> <expr: RhsEqExpr?> => {
        let ismut = ismut.is_some();
        let expr = expr.unwrap_or_else(|| Box::new((ast::expr::variable(name.0), name.1)));
        (name, expr, ismut, ty)
    },
}

RecordTypeHint = "type" <Ident> "=" <SType>;
RecordTypesList = (<RecordTypeHint> ";")*;
RecordSub = "{" <Spanned<RecordTypesList>> <SepListOpt<KeyPairExpr, ";">> "}";
Record: ast::Expr = {
    Spanned<RecordSub> => {
        let ((types, fields), span) = <>;
        let sub = (ast::expr::record(fields), span);
        ast::expr::instantiate_exist(Box::new(sub), types, ast::InstantiateSourceKind::ImplicitRecord)
    }
}

VarOrLiteral: ast::Expr = {
    Spanned<StringIdent> => {
        let (s, span) = <>;
        match s {
            "false" | "true" => ast::expr::literal(ast::Literal::Bool, (String::from(s), span)),
            _ => {
                ast::expr::variable(ctx.strings.get_or_intern(s))
            }
        }
    },

    Spanned<FloatLiteral> => ast::expr::literal(ast::Literal::Float, <>),
    Spanned<FloatLiteralNoDot> => ast::expr::literal(ast::Literal::Float, <>),
    Spanned<IntLiteral> => ast::expr::literal(ast::Literal::Int, <>),
    Spanned<StringLiteral> => ast::expr::literal(ast::Literal::Str, <>),
}

SimpleExpr = {
    FieldAccessExpr,
    InstantiateExist,
    InstantiateUni,
    Record,
    VarOrLiteral,
    "(" <Expr> ")",
    "(" <Box<SExpr>> ":" <SType> ")" => ast::expr::typed(<>),
    "begin" <Expr> "end",
}
SSimpleExpr = Spanned<SimpleExpr>;
//////////////////////////////////////////////////////////////////////
// CallExpr //////////////////////////////////////////////////////////
Case: ast::Expr = {
    Spanned<Tag> Box<SCallExpr> => ast::expr::case(<>),
}
Call: ast::Expr = {
    // Function expression must be SimpleExpr so instantiation suggestions work correctly.
    Box<SSimpleExpr> Box<SCallExpr> => ast::expr::call(<>, false),
}
CallExpr = {
    SimpleExpr,
    Case,
    Call,
}
SCallExpr = Spanned<CallExpr>;


ReverseCall: ast::Expr = {
    // Function expression must be SimpleExpr so instantiation suggestions work correctly.
    <arg: Box<Spanned<RevCallExpr>>> "|>" <func: Box<SSimpleExpr>> => ast::expr::call(func, arg, true),
}
RevCallExpr = {
    CallExpr,
    ReverseCall,
}



//////////////////////////////////////////////////////////////////////
// Binary expressions/////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
BinOp<Left, Op, Right>: ast::Expr = {
    <lhs: Box<Left>> <op: Op> <rhs: Box<Right>> => {
        ast::expr::binop(lhs, rhs, op.0, op.1)
    },
};


MultOpSub: (ast::OpType, ast::Op) = {
    // Have to make this a separate rule because * is used for tuple types too
    "*" => (ast::INT_OP, ast::Op::Mult),
    <l: @L> <op: r"[\*/%]\.?"> <r: @R> => {
        match op {
            // "*" => (ast::INT_OP, ast::Op::Mult),
            "/" => (ast::INT_OP, ast::Op::Div),
            "%" => (ast::INT_OP, ast::Op::Rem),
            "*." => (ast::FLOAT_OP, ast::Op::Mult),
            "/." => (ast::FLOAT_OP, ast::Op::Div),
            "%." => (ast::FLOAT_OP, ast::Op::Rem),
            _ => unreachable!(),
        }
    }
}
MultOp: ast::Expr = BinOp<Spanned<MultExpr>, MultOpSub, Spanned<RevCallExpr>>;

AddOpSub: (ast::OpType, ast::Op) = {
    <l: @L> <op: r"[\+\-]\.?|\^"> <r: @R> => {
        match op {
            "+" => (ast::INT_OP, ast::Op::Add),
            "-" => (ast::INT_OP, ast::Op::Sub),
            "+." => (ast::FLOAT_OP, ast::Op::Add),
            "-." => (ast::FLOAT_OP, ast::Op::Sub),
            "^" => (ast::STR_OP, ast::Op::Add),
            _ => unreachable!(),
        }
    }
}
AddOp: ast::Expr = BinOp<Spanned<AddExpr>, AddOpSub, Spanned<MultExpr>>;

CmpOpSub: (ast::OpType, ast::Op) = {
    <l: @L> <op: r"[<>]=?\.?|[!=]="> <r: @R> => {
        match op {
            "<" => (ast::INT_CMP, ast::Op::Lt),
            "<=" => (ast::INT_CMP, ast::Op::Lte),
            ">" => (ast::INT_CMP, ast::Op::Gt),
            ">=" => (ast::INT_CMP, ast::Op::Gte), 

            "<." => (ast::FLOAT_CMP, ast::Op::Lt),
            "<=." => (ast::FLOAT_CMP, ast::Op::Lte),
            ">." => (ast::FLOAT_CMP, ast::Op::Gt),
            ">=." => (ast::FLOAT_CMP, ast::Op::Gte),

            "==" => (ast::ANY_CMP, ast::Op::Eq),
            "!=" => (ast::ANY_CMP, ast::Op::Neq),
            _ => unreachable!(),
        }
    }
}
CmpOp: ast::Expr = BinOp<Spanned<AddExpr>, CmpOpSub, Spanned<AddExpr>>;

MultExpr = {
    RevCallExpr,
    MultOp,
}
AddExpr = {
    MultExpr,
    AddOp,
}
CompareExpr = {
    AddExpr,
    CmpOp,
}
SCompareExpr = Spanned<CompareExpr>;

//////////////////////////////////////////////////////////////////////
// Patterns //////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
VarPatName: (Option<ast::StringId>, spans::Span) = {
    <Spanned<Ident>> => {
        let (name, span) = <>;
        let name = if ctx.strings.resolve(&name) == "_" {None} else {Some(name)};
        (name, span)
    }
}

TypeAscription = ":" <SType>;
KeyPairPattern: (spans::Spanned<ast::StringId>, Box<ast::LetPattern>) = {
    <name: Spanned<Ident>> "=" <pat: LetPattern> => (name, Box::new(pat)),
    <name: Spanned<Ident>> <ty: TypeAscription?> => (name, Box::new(ast::LetPattern::Var((Some(name.0), name.1), ty))),
}
RecordPatternTypeParams = ("type" <TypeParam> ";")*;
RecordLetPattern = {
    "{" <RecordPatternTypeParams> <SepListOpt<KeyPairPattern, ";">> "}"
}
TupleOrParensLetPattern: ast::LetPattern = {
    Spanned<("(" <SepList<Spanned<LetPattern>, ",">> ")")> => {
        ast::make_tuple_pattern(<>, &mut ctx.strings)
    }
}


LetPatternNoIdent: ast::LetPattern = {
    <Spanned<Tag>> <Box<LetPatternNoTypedIdent>> => ast::LetPattern::Case(<>),
    Spanned<RecordLetPattern> => ast::LetPattern::Record(<>),
    TupleOrParensLetPattern,
    // "(" <LetPattern> ")" => <>,
}
// Allow bare identifiers only if they have no type annotation
LetPatternNoTypedIdent: ast::LetPattern = {
    <VarPatName> => ast::LetPattern::Var(<>, None),
    <LetPatternNoIdent> => <>,
}
LetPattern: ast::LetPattern = {
    <VarPatName> <TypeAscription?> => ast::LetPattern::Var(<>),
    <LetPatternNoIdent> => <>,
}




//////////////////////////////////////////////////////////////////////
// Top level expressions /////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
CompareOrTupleExpr: ast::Expr = {
    SepList<SCompareExpr, ","> => 
        ast::make_tuple_expr(<>, &mut ctx.strings)
}


FieldSetExpr: ast::Expr = {
    <Box<SSimpleExpr>> <FieldAccess> "<-" <Box<SNoSemiExpr>> => {
        ast::expr::field_set(<>)
    }
}


FuncDefTypeParamList = "(" "type" <TypeParam+> ")";
NoFunTypeAscription = ":" <SNoFunType>;
FuncDef: ast::Expr = {
    "fun" <FuncDefTypeParamList?> <Spanned<LetPatternNoTypedIdent>> <NoFunTypeAscription?> "->" <Box<SNoSemiExpr>> => ast::expr::func_def(<>),
}


If: ast::Expr = {
    "if" <Spanned<Box<SExpr>>> "then" <Box<SExpr>> "else" <Box<SNoSemiExpr>> => {
        ast::expr::if_expr(<>)
    },
}


LetLHS = {
    "let" <LetPattern> "=" <Box<SNoSemiExpr>>,
}
LetRHS = {
    "in" <Box<SNoSemiExpr>>,
}
Let: ast::Expr = {
    <lhs: LetLHS> <rhs: LetRHS> => ast::expr::block(vec![ast::Statement::LetDef(lhs)], rhs),
}


LetRecDef = {
    <Ident> "=" <SNoSemiExpr>,
}
LetRecLHS = {
    "let" "rec" <SepList<LetRecDef, "and">>,
}
LetRec: ast::Expr = {
     <lhs: LetRecLHS> <rhs: LetRHS> => ast::expr::block(vec![ast::Statement::LetRecDef(lhs)], rhs),
}

LoopExpr: ast::Expr = {
    "loop" <Box<SNoSemiExpr>> => {
        ast::expr::loop_expr(<>)
    }
}


MatchArm = {
    "|" <Spanned<LetPatternNoTypedIdent>> "->" <Box<SCompareExpr>>,
}
MatchStart = "match" <Box<SExpr>>;
Match: ast::Expr = {
    <Spanned<MatchStart>> "with" <MatchArm+> => {
        ast::expr::match_expr(<>)
    }
}



NoSemiExpr = {
    CompareOrTupleExpr,
    FieldSetExpr,
    FuncDef,
    If,
    Let,
    LetRec,
    LoopExpr,
    Match,
}
SNoSemiExpr = Spanned<NoSemiExpr>;
Expr: ast::Expr = {
    <stmts: (<Statement> ";")*> <l: @L> <rest: SNoSemiExpr?> <r: @R> =>? {
        let rest = match rest {
            Some(v) => v,
            None => return Err(ParseError::User {
                error: ("SyntaxError: Block expressions must end in an expression. Expected an expression here.", ctx.span_maker.span(l, r))
            })
        };

        Ok(if stmts.is_empty() {
            rest.0
        } else {
            ast::expr::block(stmts, Box::new(rest))
        })
    }
}
SExpr = Spanned<Expr>;
//////////////////////////////////////////////////////////////////////



Statement: ast::Statement = {
    <LetLHS> => ast::Statement::LetDef(<>),
    <LetRecLHS> => ast::Statement::LetRecDef(<>),
    <SNoSemiExpr> => ast::Statement::Expr(<>),
    "print" <SepListOpt<SCompareExpr, ",">> => ast::Statement::Println(<>),
    => ast::Statement::Empty,
}

pub Script = {
   <SepList<Statement, ";">>
}
