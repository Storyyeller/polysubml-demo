// Warning, this file was mostly generated by AI.

use anyhow::{Result, anyhow};
use clap::Parser;
use compiler_lib::CompilationResult;
use compiler_lib::State;
use sha2::{Digest, Sha256};
use similar::{ChangeTag, TextDiff};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};
use std::process::{Command, Stdio};
use tempfile;

#[derive(Parser)]
#[command(name = "regression")]
#[command(about = "PolySubML Regression Test Runner")]
#[command(long_about = "Run regression tests for PolySubML by compiling and executing .ml files,
comparing outputs against expected baselines.")]
struct Args {
    /// Directory containing .ml test files
    #[arg(default_value = "tests/regression/cases")]
    test_dir: PathBuf,

    /// Update expected output baselines instead of comparing
    #[arg(short, long)]
    update_baselines: bool,

    /// Directory to cache JS execution results (optional)
    #[arg(long)]
    cache_dir: Option<PathBuf>,

    #[arg(long)]
    baseline_dir: PathBuf,
}

fn main() {
    let args = Args::parse();

    let test_path = args.test_dir;
    let baseline_path = args.baseline_dir;
    let cache_path = args.cache_dir;

    // Print paths being used
    println!("Test directory:     {}", test_path.display());
    println!("Baseline directory: {}", baseline_path.display());
    if let Some(ref cache_dir) = cache_path {
        println!("Cache directory:    {}", cache_dir.display());
    } else {
        println!("Cache directory:    None (caching disabled)");
    }
    println!();

    let tester = RegressionTester::new(test_path, baseline_path, args.update_baselines, cache_path);

    match tester.run_all_tests() {
        Ok(results) => {
            let failed_count = results.iter().filter(|r| r.status != TestStatus::Pass).count();

            if failed_count > 0 && !args.update_baselines {
                std::process::exit(1);
            }
        }
        Err(e) => {
            eprintln!("Regression test error: {}", e);
            std::process::exit(1);
        }
    }
}

// Regression testing implementation

#[derive(Debug)]
pub struct TestResult {
    pub name: String,
    pub status: TestStatus,
}

#[derive(Debug, PartialEq)]
pub enum TestStatus {
    Pass,
    CompilationMismatch {
        actual: CompilationResult,
        expected: CompilationResult,
    },
    ExecutionMismatch {
        actual_output: String,
        expected_output: String,
    },
    BaselineNotFound,
}

pub struct RegressionTester {
    test_dir: PathBuf,
    baseline_dir: PathBuf,
    update_baselines: bool,
    cache_dir: Option<PathBuf>,
}

impl RegressionTester {
    pub fn new(test_dir: PathBuf, baseline_dir: PathBuf, update_baselines: bool, cache_dir: Option<PathBuf>) -> Self {
        Self {
            test_dir,
            baseline_dir,
            update_baselines,
            cache_dir,
        }
    }

    pub fn discover_tests(&self) -> Result<Vec<PathBuf>> {
        let mut tests = Vec::new();

        if !self.test_dir.exists() {
            return Err(anyhow!("Test directory {:?} does not exist", self.test_dir));
        }

        for entry in fs::read_dir(&self.test_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && path.extension().map_or(false, |ext| ext == "ml") {
                tests.push(path);
            }
        }

        tests.sort();
        Ok(tests)
    }

    pub fn run_all_tests(&self) -> Result<Vec<TestResult>> {
        let tests = self.discover_tests()?;

        if self.update_baselines {
            println!("Updating baselines for {} tests...", tests.len());

            for test_path in &tests {
                self.update_single_baseline(test_path)?;
            }

            println!("\nBaselines updated for {} tests", tests.len());
            return Ok(Vec::new()); // Return empty results for update mode
        }

        println!("Running {} regression tests...", tests.len());
        let mut results = Vec::new();

        for test_path in tests {
            let result = self.run_single_test(&test_path)?;

            let status_char = match &result.status {
                TestStatus::Pass => "✓",
                TestStatus::CompilationMismatch { .. } => "✗",
                TestStatus::ExecutionMismatch { .. } => "✗",
                TestStatus::BaselineNotFound => "S",
            };

            println!("{} {}", status_char, result.name);

            if !matches!(result.status, TestStatus::Pass) {
                self.print_diff(&result);
            }

            results.push(result);
        }

        self.print_summary(&results);
        Ok(results)
    }

    fn compile_test(&self, test_path: &Path) -> Result<CompilationResult> {
        let test_content =
            fs::read_to_string(test_path).map_err(|e| anyhow!("Failed to read test file {}: {}", test_path.display(), e))?;

        let mut state = State::new();
        Ok(state.process(&test_content))
    }

    fn update_single_baseline(&self, test_path: &Path) -> Result<()> {
        let test_name = test_path
            .file_stem()
            .and_then(|s| s.to_str())
            .ok_or_else(|| anyhow!("Invalid test file name"))?
            .to_string();

        let baseline_path = self.baseline_dir.join(format!("{}.expected", test_name));
        let result = self.compile_test(test_path)?;
        self.save_baseline(&baseline_path, &result)?;

        println!("✓ {}\t{}", test_name, result);
        Ok(())
    }

    pub fn run_single_test(&self, test_path: &Path) -> Result<TestResult> {
        let test_name = test_path
            .file_stem()
            .and_then(|s| s.to_str())
            .ok_or_else(|| anyhow!("Invalid test file name"))?
            .to_string();

        let baseline_path = self.baseline_dir.join(format!("{}.expected", test_name));

        // Check if baseline exists first
        let expected_result = match self.load_baseline(&baseline_path) {
            Some(result) => result,
            None => {
                // No baseline exists - skip compilation entirely
                return Ok(TestResult {
                    name: test_name,
                    status: TestStatus::BaselineNotFound,
                });
            }
        };

        // Baseline exists - compile and compare
        let actual = self.compile_test(test_path)?;

        let status = if actual == expected_result {
            TestStatus::Pass
        } else {
            // Both compiled successfully but JS code differs - check execution
            match (&actual, &expected_result) {
                (CompilationResult::Success(actual_js), CompilationResult::Success(expected_js)) => {
                    // Execute both versions, treating runtime errors as part of the output
                    let actual_output = match self.execute_js(actual_js) {
                        Ok(output) => output,
                        Err(e) => format!("Runtime error: {}", e),
                    };
                    let expected_output = match self.execute_js(expected_js) {
                        Ok(output) => output,
                        Err(e) => format!("Runtime error: {}", e),
                    };

                    if actual_output == expected_output {
                        TestStatus::Pass
                    } else {
                        TestStatus::ExecutionMismatch {
                            actual_output,
                            expected_output,
                        }
                    }
                }
                _ => TestStatus::CompilationMismatch {
                    actual: actual.clone(),
                    expected: expected_result,
                },
            }
        };

        Ok(TestResult { name: test_name, status })
    }

    fn save_baseline(&self, baseline_path: &Path, result: &CompilationResult) -> Result<()> {
        fs::write(baseline_path, result.to_string())
            .map_err(|e| anyhow!("Failed to write baseline file {}: {}", baseline_path.display(), e))?;
        Ok(())
    }

    fn load_baseline(&self, baseline_path: &Path) -> Option<CompilationResult> {
        let content = fs::read_to_string(baseline_path).ok()?;
        let mut lines = content.splitn(2, '\n');
        let status = lines.next()?;
        let body = lines.next().unwrap_or("");

        match status {
            "SUCCESS" => Some(CompilationResult::Success(body.to_string())),
            "ERROR" => Some(CompilationResult::Error(body.to_string())),
            _ => None, // Invalid baseline format
        }
    }

    fn hash_js_code(&self, js_code: &str) -> String {
        let mut hasher = Sha256::new();
        hasher.update(js_code.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    fn get_cached_result(&self, js_code: &str) -> Option<String> {
        let cache_dir = self.cache_dir.as_ref()?;
        let hash = self.hash_js_code(js_code);
        let cache_file = cache_dir.join(format!("{}.output", hash));
        fs::read_to_string(cache_file).ok()
    }

    fn cache_result(&self, js_code: &str, result: &str) -> Result<()> {
        if let Some(cache_dir) = &self.cache_dir {
            let hash = self.hash_js_code(js_code);
            let cache_file = cache_dir.join(format!("{}.output", hash));
            fs::write(&cache_file, result)
                .map_err(|e| anyhow!("Failed to write cache file {}: {}", cache_file.display(), e))?;
        }
        Ok(())
    }

    fn execute_js(&self, compiled_code: &str) -> Result<String> {
        // Check cache first
        if let Some(cached_result) = self.get_cached_result(compiled_code) {
            return Ok(cached_result);
        }

        if !self.check_node_available() {
            return Err(anyhow!("Node.js is required but not available"));
        }

        let temp_file = tempfile::Builder::new().suffix(".js").tempfile()?;

        let js_runtime = include_str!("../js_runtime.js");
        let js_code = format!("{}\nexecute(String.raw`{}`);", js_runtime, compiled_code.replace('`', "\\`"));

        temp_file.as_file().write_all(js_code.as_bytes())?;

        let result = if Command::new("timeout").arg("--version").output().is_ok() {
            Command::new("timeout").arg("10s").arg("node").arg(temp_file.path()).output()
        } else {
            Command::new("node").arg(temp_file.path()).output()
        };

        let output = result?;

        if let Some(124) = output.status.code() {
            return Err(anyhow!("Execution timeout exceeded (10 seconds)"));
        }

        if !output.status.success() {
            return Err(anyhow!(
                "Node.js execution failed: {}",
                String::from_utf8_lossy(&output.stderr)
            ));
        }

        let result_string = String::from_utf8_lossy(&output.stdout).to_string();

        // Cache the result
        self.cache_result(compiled_code, &result_string)?;

        Ok(result_string)
    }

    fn check_node_available(&self) -> bool {
        Command::new("node")
            .arg("--version")
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status()
            .map(|status| status.success())
            .unwrap_or(false)
    }

    fn print_diff(&self, result: &TestResult) {
        println!("  DIFF for {}:", result.name);

        match &result.status {
            TestStatus::BaselineNotFound => {
                println!("    No baseline found - test skipped");
            }
            TestStatus::CompilationMismatch { actual, expected } => {
                println!("    Compilation result mismatch:");
                self.show_text_diff(&expected.to_string(), &actual.to_string());
            }
            TestStatus::ExecutionMismatch {
                actual_output,
                expected_output,
            } => {
                println!("    Execution output differs:");
                self.show_text_diff(expected_output, actual_output);
            }
            TestStatus::Pass => {
                // Should not be called for passing tests
            }
        }
    }

    fn show_text_diff(&self, expected: &str, actual: &str) {
        let diff = TextDiff::from_lines(expected, actual);

        println!("    Expected vs Actual:");
        for change in diff.iter_all_changes() {
            let sign = match change.tag() {
                ChangeTag::Delete => format!("\x1b[31m-{}\x1b[0m", change),
                ChangeTag::Insert => format!("\x1b[32m+{}\x1b[0m", change),
                ChangeTag::Equal => format!(" {}", change),
            };
            print!("    {}", sign);
        }

        if !expected.ends_with('\n') || !actual.ends_with('\n') {
            println!();
        }
    }

    fn print_summary(&self, results: &[TestResult]) {
        let total = results.len();
        let passed = results.iter().filter(|r| matches!(r.status, TestStatus::Pass)).count();
        let skipped = results
            .iter()
            .filter(|r| matches!(r.status, TestStatus::BaselineNotFound))
            .count();
        let failed = total - passed - skipped;

        println!(
            "\nTest Results: {} passed, {} failed, {} skipped, {} total",
            passed, failed, skipped, total
        );

        if failed > 0 {
            println!("\nFailed tests:");
            for result in results.iter().filter(|r| {
                matches!(
                    r.status,
                    TestStatus::CompilationMismatch { .. } | TestStatus::ExecutionMismatch { .. }
                )
            }) {
                let status_name = match &result.status {
                    TestStatus::CompilationMismatch { .. } => "CompilationMismatch",
                    TestStatus::ExecutionMismatch { .. } => "ExecutionMismatch",
                    _ => unreachable!(),
                };
                println!("  {} ({})", result.name, status_name);
            }
        }

        if skipped > 0 {
            println!("\nSkipped tests (no baseline):");
            for result in results.iter().filter(|r| matches!(r.status, TestStatus::BaselineNotFound)) {
                println!("  {}", result.name);
            }
        }
    }
}
