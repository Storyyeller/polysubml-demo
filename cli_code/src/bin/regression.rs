// Warning, this file was mostly generated by AI.

use anyhow::{Result, anyhow};
use clap::Parser;
use cli_lib::js_executor::JsExecutor;
use compiler_lib::CompilationResult;
use compiler_lib::State;
use similar::{ChangeTag, TextDiff};
use std::fs;
use std::io::Write;
use std::path::{Path, PathBuf};

#[derive(Parser)]
#[command(name = "regression")]
#[command(about = "PolySubML Regression Test Runner")]
#[command(long_about = "Run regression tests for PolySubML by compiling and executing .ml files,
comparing outputs against expected baselines.")]
struct Args {
    /// Directories containing .ml test files
    #[arg(default_value = "tests/regression/cases")]
    test_dirs: Vec<PathBuf>,

    /// Update expected output baselines instead of comparing
    #[arg(short, long)]
    update_baselines: bool,

    /// Directory to cache JS execution results (optional)
    #[arg(long)]
    cache_dir: Option<PathBuf>,

    #[arg(long)]
    baseline_dir: PathBuf,
}

fn main() {
    let args = Args::parse();

    let test_dirs = args.test_dirs;
    let baseline_path = args.baseline_dir;
    let cache_path = args.cache_dir;

    // Print paths being used
    println!(
        "Test directories:   {}",
        test_dirs
            .iter()
            .map(|p| p.display().to_string())
            .collect::<Vec<_>>()
            .join(", ")
    );
    println!("Baseline directory: {}", baseline_path.display());
    if let Some(ref cache_dir) = cache_path {
        println!("Cache directory:    {}", cache_dir.display());
    } else {
        println!("Cache directory:    None (caching disabled)");
    }
    println!();

    let tester = RegressionTester::new(test_dirs, baseline_path, args.update_baselines, cache_path);

    match tester.run_all_tests() {
        Ok(results) => {
            let failed_count = results.iter().filter(|r| r.status != TestStatus::Pass).count();

            if failed_count > 0 && !args.update_baselines {
                std::process::exit(1);
            }
        }
        Err(e) => {
            eprintln!("Regression test error: {}", e);
            std::process::exit(1);
        }
    }
}

// Regression testing implementation

#[derive(Debug)]
pub struct TestResult {
    pub name: String,
    pub status: TestStatus,
}

#[derive(Debug, PartialEq)]
pub enum TestStatus {
    Pass,
    CompilationMismatch {
        actual: CompilationResult,
        expected: CompilationResult,
    },
    ExecutionMismatch {
        actual_output: String,
        expected_output: String,
    },
    BaselineNotFound,
}

pub struct RegressionTester {
    test_dirs: Vec<PathBuf>,
    baseline_dir: PathBuf,
    update_baselines: bool,
    js_executor: JsExecutor,
}

impl RegressionTester {
    pub fn new(test_dirs: Vec<PathBuf>, baseline_dir: PathBuf, update_baselines: bool, cache_dir: Option<PathBuf>) -> Self {
        Self {
            test_dirs,
            baseline_dir,
            update_baselines,
            js_executor: JsExecutor::new(cache_dir),
        }
    }

    pub fn discover_tests(&self) -> Result<Vec<PathBuf>> {
        let mut tests = Vec::new();

        for test_dir in &self.test_dirs {
            if !test_dir.exists() {
                return Err(anyhow!("Test directory {:?} does not exist", test_dir));
            }

            for entry in fs::read_dir(test_dir)? {
                let entry = entry?;
                let path = entry.path();

                if path.is_file() && path.extension().map_or(false, |ext| ext == "ml") {
                    tests.push(path);
                }
            }
        }

        tests.sort();
        Ok(tests)
    }

    pub fn run_all_tests(&self) -> Result<Vec<TestResult>> {
        let tests = self.discover_tests()?;

        if self.update_baselines {
            println!("Updating baselines for {} tests...", tests.len());

            for test_path in &tests {
                self.update_single_baseline(test_path)?;
            }

            println!("\nBaselines updated for {} tests", tests.len());
            return Ok(Vec::new()); // Return empty results for update mode
        }

        println!("Running {} regression tests...", tests.len());
        let mut results = Vec::new();

        for test_path in tests {
            // Print test name before running
            let test_name = test_path.file_stem().and_then(|s| s.to_str()).unwrap_or("unknown");
            print!("{}", test_name);
            std::io::stdout().flush().unwrap();

            let result = self.run_single_test(&test_path)?;

            let status_char = match &result.status {
                TestStatus::Pass => " ✓",
                TestStatus::CompilationMismatch { .. } => " ✗",
                TestStatus::ExecutionMismatch { .. } => " ✗",
                TestStatus::BaselineNotFound => " S",
            };

            println!("{}", status_char);

            if !matches!(result.status, TestStatus::Pass) {
                self.print_diff(&result);
            }

            results.push(result);
        }

        self.print_summary(&results);
        Ok(results)
    }

    fn compile_test(&self, test_path: &Path) -> Result<CompilationResult> {
        let test_content =
            fs::read_to_string(test_path).map_err(|e| anyhow!("Failed to read test file {}: {}", test_path.display(), e))?;

        let mut state = State::new();
        Ok(state.process(&test_content))
    }

    fn update_single_baseline(&self, test_path: &Path) -> Result<()> {
        let test_name = test_path
            .file_stem()
            .and_then(|s| s.to_str())
            .ok_or_else(|| anyhow!("Invalid test file name"))?
            .to_string();

        let baseline_path = self.baseline_dir.join(format!("{}.expected", test_name));
        let result = self.compile_test(test_path)?;
        self.save_baseline(&baseline_path, &result)?;

        println!("✓ {}\t{}", test_name, result);
        Ok(())
    }

    pub fn run_single_test(&self, test_path: &Path) -> Result<TestResult> {
        let test_name = test_path
            .file_stem()
            .and_then(|s| s.to_str())
            .ok_or_else(|| anyhow!("Invalid test file name"))?
            .to_string();

        let baseline_path = self.baseline_dir.join(format!("{}.expected", test_name));

        // Check if baseline exists first
        let expected_result = match self.load_baseline(&baseline_path) {
            Some(result) => result,
            None => {
                // No baseline exists - skip compilation entirely
                return Ok(TestResult {
                    name: test_name,
                    status: TestStatus::BaselineNotFound,
                });
            }
        };

        // Baseline exists - compile and compare
        let actual = self.compile_test(test_path)?;

        let status = if actual == expected_result {
            TestStatus::Pass
        } else {
            // Both compiled successfully but JS code differs - check execution
            match (&actual, &expected_result) {
                (CompilationResult::Success(actual_js), CompilationResult::Success(expected_js)) => {
                    // Execute both versions, treating runtime errors as part of the output
                    let actual_output = match self.js_executor.execute_js(actual_js) {
                        Ok(output) => output,
                        Err(e) => format!("Runtime error: {}", e),
                    };
                    let expected_output = match self.js_executor.execute_js(expected_js) {
                        Ok(output) => output,
                        Err(e) => format!("Runtime error: {}", e),
                    };

                    if actual_output == expected_output {
                        TestStatus::Pass
                    } else {
                        TestStatus::ExecutionMismatch {
                            actual_output,
                            expected_output,
                        }
                    }
                }
                _ => TestStatus::CompilationMismatch {
                    actual: actual.clone(),
                    expected: expected_result,
                },
            }
        };

        Ok(TestResult { name: test_name, status })
    }

    fn save_baseline(&self, baseline_path: &Path, result: &CompilationResult) -> Result<()> {
        fs::write(baseline_path, result.to_string())
            .map_err(|e| anyhow!("Failed to write baseline file {}: {}", baseline_path.display(), e))?;
        Ok(())
    }

    fn load_baseline(&self, baseline_path: &Path) -> Option<CompilationResult> {
        let content = fs::read_to_string(baseline_path).ok()?;
        let mut lines = content.splitn(2, '\n');
        let status = lines.next()?;
        let body = lines.next().unwrap_or("");

        match status {
            "SUCCESS" => Some(CompilationResult::Success(body.to_string())),
            "ERROR" => Some(CompilationResult::Error(body.to_string())),
            _ => None, // Invalid baseline format
        }
    }

    fn print_diff(&self, result: &TestResult) {
        println!("  DIFF for {}:", result.name);

        match &result.status {
            TestStatus::BaselineNotFound => {
                println!("    No baseline found - test skipped");
            }
            TestStatus::CompilationMismatch { actual, expected } => {
                println!("    Compilation result mismatch:");
                self.show_text_diff(&expected.to_string(), &actual.to_string());
            }
            TestStatus::ExecutionMismatch {
                actual_output,
                expected_output,
            } => {
                println!("    Execution output differs:");
                self.show_text_diff(expected_output, actual_output);
            }
            TestStatus::Pass => {
                // Should not be called for passing tests
            }
        }
    }

    fn show_text_diff(&self, expected: &str, actual: &str) {
        let diff = TextDiff::from_lines(expected, actual);

        println!("    Expected vs Actual:");
        for change in diff.iter_all_changes() {
            let sign = match change.tag() {
                ChangeTag::Delete => format!("\x1b[31m-{}\x1b[0m", change),
                ChangeTag::Insert => format!("\x1b[32m+{}\x1b[0m", change),
                ChangeTag::Equal => format!(" {}", change),
            };
            print!("    {}", sign);
        }

        if !expected.ends_with('\n') || !actual.ends_with('\n') {
            println!();
        }
    }

    fn print_summary(&self, results: &[TestResult]) {
        let total = results.len();
        let passed = results.iter().filter(|r| matches!(r.status, TestStatus::Pass)).count();
        let skipped = results
            .iter()
            .filter(|r| matches!(r.status, TestStatus::BaselineNotFound))
            .count();
        let failed = total - passed - skipped;

        println!(
            "\nTest Results: {} passed, {} failed, {} skipped, {} total",
            passed, failed, skipped, total
        );

        if failed > 0 {
            println!("\nFailed tests:");
            for result in results.iter().filter(|r| {
                matches!(
                    r.status,
                    TestStatus::CompilationMismatch { .. } | TestStatus::ExecutionMismatch { .. }
                )
            }) {
                let status_name = match &result.status {
                    TestStatus::CompilationMismatch { .. } => "CompilationMismatch",
                    TestStatus::ExecutionMismatch { .. } => "ExecutionMismatch",
                    _ => unreachable!(),
                };
                println!("  {} ({})", result.name, status_name);
            }
        }

        if skipped > 0 {
            println!("\nSkipped tests (no baseline):");
            for result in results.iter().filter(|r| matches!(r.status, TestStatus::BaselineNotFound)) {
                println!("  {}", result.name);
            }
        }
    }
}
