// Warning, this file was mostly generated by AI.

use anyhow::{Result, anyhow};
use sha2::{Digest, Sha256};
use std::fs;
use std::io::Write;
use std::path::PathBuf;
use std::process::{Command, Stdio};
use tempfile;

pub struct JsExecutor {
    cache_dir: Option<PathBuf>,
}

impl JsExecutor {
    pub fn new(cache_dir: Option<PathBuf>) -> Self {
        Self { cache_dir }
    }

    fn hash_js_code(&self, js_code: &str) -> String {
        let mut hasher = Sha256::new();
        hasher.update(js_code.as_bytes());
        format!("{:x}", hasher.finalize())
    }

    fn get_cached_result(&self, js_code: &str) -> Option<String> {
        let cache_dir = self.cache_dir.as_ref()?;
        let hash = self.hash_js_code(js_code);
        let cache_file = cache_dir.join(format!("{}.output", hash));
        fs::read_to_string(cache_file).ok()
    }

    fn cache_result(&self, js_code: &str, result: &str) -> Result<()> {
        if let Some(cache_dir) = &self.cache_dir {
            fs::create_dir_all(cache_dir)?;
            let hash = self.hash_js_code(js_code);
            let cache_file = cache_dir.join(format!("{}.output", hash));
            fs::write(&cache_file, result)
                .map_err(|e| anyhow!("Failed to write cache file {}: {}", cache_file.display(), e))?;
        }
        Ok(())
    }

    pub fn execute_js(&self, compiled_code: &str) -> Result<String> {
        // Check cache first
        if let Some(cached_result) = self.get_cached_result(compiled_code) {
            return Ok(cached_result);
        }

        if !self.check_node_available() {
            return Err(anyhow!("Node.js is required but not available"));
        }

        let temp_file = tempfile::Builder::new().suffix(".js").tempfile()?;

        let js_runtime = include_str!("js_runtime.js");
        let js_code = format!("{}\nexecute(String.raw`{}`);", js_runtime, compiled_code.replace('`', "\\`"));

        temp_file.as_file().write_all(js_code.as_bytes())?;

        let result = if Command::new("timeout").arg("--version").output().is_ok() {
            Command::new("timeout").arg("10s").arg("node").arg(temp_file.path()).output()
        } else {
            Command::new("node").arg(temp_file.path()).output()
        };

        let output = result?;

        if let Some(124) = output.status.code() {
            return Err(anyhow!("Execution timeout exceeded (10 seconds)"));
        }

        if !output.status.success() {
            return Err(anyhow!(
                "Node.js execution failed: {}",
                String::from_utf8_lossy(&output.stderr)
            ));
        }

        let result_string = String::from_utf8_lossy(&output.stdout).to_string();

        // Cache the result
        self.cache_result(compiled_code, &result_string)?;

        Ok(result_string)
    }

    fn check_node_available(&self) -> bool {
        Command::new("node")
            .arg("--version")
            .stdout(Stdio::null())
            .stderr(Stdio::null())
            .status()
            .map(|status| status.success())
            .unwrap_or(false)
    }
}
